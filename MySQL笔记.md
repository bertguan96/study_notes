# MySQL背诵

## 数据库三大范式

第一范式

强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。

第二范式

关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。

第三范式

关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。

## MySQL架构

MySQL可以分为应用层,逻辑层,数据库引擎层,物理层。

应用层：负责和客户端，响应客户端请求，建立连接，返回数据。

逻辑层：包括SQK接口，解析器，优化器，Cache与buffer。

数据库引擎层：有常见的MyISAM,InnoDB等等。

物理层：负责文件存储，日志等等。

## SQL执行过程

1. 客户端首先通过连接器进行身份认证和权限相关
2. 如果是执行查询语句的时候，会先查询缓存，但MySQL 8.0 版本后该步骤移除。
3. 没有命中缓存的话，SQL 语句就会经过解析器，分析语句，包括语法检查等等。
4. 通过优化器，将用户的SQL语句按照 MySQL 认为最优的方案去执行。
5. 执行语句，并从存储引擎返回数据。
6. 写入undo log
7. 写入缓冲池
8. 写入bin log（这个就是用于做master / slave的时候使用的日志）

### SQL执行过程优化

1. 通过慢日志定位执行较慢的SQL语句。
2. 利用explain对这些关键字段进行分析。
3. 根据分析结果进行优化。（采取适当的索引）

## 锁

共享锁：也称为读锁，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。

排他锁：也成为写锁，会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。

表级锁: 对当前操作的整张表加锁,实现简单，加锁快，但并发能力低。

行锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，**那么 InnoDB 会创建一个隐藏的聚簇索引加锁**。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但**加锁的开销也最大，加锁慢，会出现死锁。**

### 死锁

在MySQL中，MyISAM是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。在InnoDB存储引擎中，除了单个SQL组成的事务外，锁都是逐步获得的，所以存在死锁问题。

解决死锁：

1. 预先检测到死锁的循环依赖，并立即返回一个错误。

2. 当查询的时间达到锁等待超时的设定后放弃锁请求。

### 乐观锁和悲观锁

**乐观锁：**对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。这种一般使用版本号来区别。

**悲观锁：**对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。简单一句话就是，乐观锁，始终觉得数据存在冲突。

**悲观锁的实现方式：通过数据库的锁机制实现，对查询语句添加for updata。**

## 存储引擎

### InnoDB

InnoDB 是 MySQL 的默认事务型引擎，支持事务，表是基于聚簇索引建立的。支持表级锁和行级锁，支持外键，适合数据增删改查都频繁的情况。

**InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。**其默认级别是 REPEATABLE READ，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。

InnoDB计算行数的时候需要去扫表

### MyISAM

MyISAM 是默认存储引擎。MyISAM不支持事务，Myisam支持表级锁，不支持行级锁，表不支持外键，该存储引擎存有表的行数，count运算会更快。适合查询频繁，不适合对于增删改要求高的情况。

## *索引

索引是存储引擎中用于快速找到记录的一种数据结构。

### 常见索引

- B-Tree索引 
- Hash索引 
- R-Tree索引 
- 全文索引

#### Hash索引

哈希索引对于每一行数据计算一个哈希码，并将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。**只有 Memory 引擎显式支持哈希索引。**

<u>Hash索引不支持范围查询，无法用于排序，也不支持部分索引列匹配查找。</u>

一般使用在等值查询的情况。

**简述自适应Hash索引**

InnoDB对于频繁使用的某些索引值，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这也被称为自适应Hash索引。

#### 全文索引

一般用于查找文本中的关键字，而不是直接比较是否相等，多在CHAR，VARCHAR，TAXT等数据类型上创建全文索引。全文索引主要是用来解决WHERE name LIKE "%zhang%"等针对文本的模糊查询效率低的问题。

#### BTree索引

BTREE即B+树索引，INnoDB存储引擎默认的索引，支持排序、分组、范围查询、模糊查询等，并且性能稳定。

#### RTree索引

RTREE即空间数据索引，多用于地理数据的存储，相比于其他索引，空间数据索引的优势在于范围查找

### 索引的种类

主键索引：数据列不允许重复，不能为NULL，一个表只能有一个主键索引

组合索引：由多个列值组成的索引。

唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。

全文索引：对文本的内容进行搜索。

普通索引：基本的索引类型，可以为NULL

### 聚簇索引和非聚簇索引

聚簇索引和非聚簇索引最主要的区别是数据和索引是否分开存储。

聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。

非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。

在InnoDB存储引擎中，默认的索引为B+树索引，利用主键创建的索引为主索引，也是聚簇索引，在主索引之上创建的索引为辅助索引，也是非聚簇索引。

## *事务

事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。

每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。

每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。

### 事务的基本特性？

原子性，一致性，隔离性，持久性。

### 事务并发可能出现的问题？

脏读，幻读，不可重复读，修改丢失。

### 事务隔离级别？

- 未提交读：一个事务在提交前，它的修改对其他事务也是可见的。

- 提交读：一个事务提交之后，它的修改才能被其他事务看到。

- 可重复读：在同一个事务中多次读取到的数据是一致的。

- 串行化：需要加锁实现，会强制事务串行执行（此操作会加锁，会影响使用性能）。

MySQL的默认隔离级别是可重复读。

### 隔离级别是如何实现的？

事务的隔离机制主要是依靠锁机制和MVCC(多版本并发控制)实现的，提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。

### 什么是MVCC？

MVCC(multiple version concurrent control)是一种控制并发的方法，主要用来提高数据库的并发性能。

## 优化

### SQL执行过慢

分析慢查询日志，找到执行比较慢的SQL，分析是否命中索引，如果没有，可以调整查询语句。

使用explain进行SQL语句分析。

进行分析优化。

### 大表数据优化

1.读写分离，主从复制。

2.增加查询缓存，将一些查询过的结果写入redis（不过这里需要考虑双写一致性的问题）

3.优化索引，SQL语句。

4.分库分表。

### 查询优化

1.是否命中索引。

2.是否单个库并发太高，导致性能下降。

3.避免使用select *。

4.相同数据添加缓存。

5.调整表结构到更合理的布局。

6.重写SQL语句，让优化器可以以更优的方式执行查询。

## 参考文献

https://blog.51cto.com/u_15437298/4692501

https://zhuanlan.zhihu.com/p/403656116

https://zhuanlan.zhihu.com/p/366840427